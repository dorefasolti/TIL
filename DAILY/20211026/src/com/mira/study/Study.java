package com.mira.study;

public class Study {
	
	
	
//-----------------------------------1번-----------------------------
	
	
//	클래스는 크게 세부분으로 나눌 수 있다
//	필드부, 생성자부, 메소드부
	
//	필드부 : 각 정보를 담는 부분
//			필드 == 멤버변수 == 인스턴스변수 == 클래스변수
//			접근제한자 자료형 필드이름;
	
	
//	생성자부 : 단지 객체를 생성할 목적으로 사용
//			메모리의 공간이 할당 될 때, 공간을 확보할 때
//			메소드 이름이 클래스이름과 동일하고 반환형이 없는 메소드
//			객체가 생성될 때 호출되는 메소드
		
		
//	메소드부 : 각 기능을 구현하는 부분
//				메소드를 호출한 곳으로 돌아갈 때 반환형의 형식으로 들고 갈 것,
//				특정 형식이 필요한 상황이 아닐 땐 void
//				메소드 결과값의 자료형을 지정, void == 돌려줄 값이 없다
//		접근제한자 반환형 메소드이름(매개변수) { => 매개변수의 형식으로 입력받고 반환형으로 출력
//							매개변수 형을 인트로 지정했다면!
//							무조건 인트로 입력받아야한다
//							인자라고 부르기도 한다
//							해당 메소드 실행 중에만 사용 가능
//							생략 가능
//				실행할 코드;
//		}
				
		
//	setter 메소드 : 데이터를 기록, 수정하는 메소드
	//	1. setter메소드는 접근이 가능하도록 만들어야 하기 때문에 접근제한자는 public
	//	2. set 필드명으로 이름짓되, 카멜표기법으로 사용해야한다
	//	3. 모든 필드에 대해 전부 작성해야한다
	//	4. 변수 하나에 setter 하나만 지정할 수 있다 set name, age X setName, setAge
	
		private String name; //(멤버변수)
		
//				setter는 stter 이외 추가 기능이 있으면 안된다 => 반환값? 당연히 없다 => void
		public void setName(String name) { 

//		this.name == private String name;
		this.name = name;
//					(String name) 매개변수
		
//		멤버변수에 this.를 붙이는 이유
//		특정 영역 안에서는 해당 영역 안에 있는 지역변수가 우선된다
//		=> this로 멤버변수를 구분해주지 않으면 매개변수 name = 매개변수 name 이란 뜻이 되어버림
	}
		
		
//	getter 메소드 : 데이터를 반환해주는 기능의 메소드
//	
	//	1. getter 메소드는 접근제한자 public을 사용
	//	2. get필드명으로 이름짓되, 카멜표기법 사용
	//	3. 모든 필드에 대해 모두 작성
//		
//		private String name;(멤버변수)
//		
//		
		public String getName() {
			return this.name; //리턴하면서 반환하기
			//return 결과값 => 결과값을 돌려주겠다
			//메소드의 반환형과 결과값 반환형이 동일한지 확인
		}
		
		
		
	/* setter와 getter를 만들었으면 캡슐화 끝*/
	
//		캡슐화를 하지 않는 경우
//		=> 외부로부터 직접 접근이 가능하기 때문에 함부로 값이 변질되거나 조회하는 것을 막지 못하는 문제(보안성)
//		
//		캡슐화 작업은 정보은닉 기술 중 하나로,
//		데이터의 "접근제한"을 원칙으로 하여 외부로부터 직접 접근을 막는다
//		단, 메소드를 통해 간접적으로 처리할 수 있다
//		
//		캡슐화 작업
//		1. 값을 숨김 : 접근제한자 private 사용
//		2. 간접적으로 값을 처리할 수 있는 메서드 만듦(getter/setter)
//		
//		
		
		
//	------------------------------------1번 끝 ------------------------------
		
		
		
		
//	------------------------------------2 - 1 번 시작 ------------------------------
		

//		필드 : 클래스를 구성하는 요소 중 하나
//			클래스 내부지만 메소드 밖 영역의 정의
//			어떠한 데이터를 저장하기 위한 역할(변수)
//		
//		
//		변수(전역변수, 지역변수)
		
		
		
		
//		전역변수
//		클래스 영역에 바로 선언하는 변수
//		클래스 내 어디서든 사용 가능
			
	//		1. 멤버변수(인스턴스 변수, 필드)
	//		생성시점 : new 키워드를 사용해 해당 객체를 생성하는 순간 heap 메모리에 할당
	//		소멸시점 : 객체가 소멸될 때(래퍼런스카운트가 0) => 가비지컬렉터가 수거
	//		
	//		2. 클래스변수(static 변수) static이라는 예약어가 붙은 변수
	//		생성시점 : 프로그램 실행과 동시에 static 영역에 할당
	//				해당 객체가 생성되지 않아도 무조건 프로그램 실행과 동시에 할당
	//				=> 객체를 생성하지 않고 할당된다
	//		소멸시점 : 프로그램이 끝날 때 소멸		

		
		
//		지역변수
//		클래스 영역 내의 특정한 구역 ({스코프 내})
//		반드시 초기화를 해줘야 한다
	//		생성시점 : 특정 구역({스코프 내}) 실행 시 stack 영역에 할당
	//		소멸시점 : 특정 구역({스코프 내}) 종료 시 소멸
	//		

		
		private int memberB; // 멤버변수, 인스턴스변수, 필드
		public void test(int maegaeB) { //test 메소드 시작
				//지역변수 사용
			
			int localB = 0; // 초기화
			System.out.println(memberB);
			//멤버변수를 전역변수라고 하기 힘든 이유
			//=> 객체가 소멸되면 같이 소멸
			System.out.println(localB);
			//지역변수
			System.out.println(maegaeB);
			//매개변수
			
		} //test메소드영역 끝
		
		
		
//		------------------------------------2 - 1 번 끝 ------------------------------

		
		
//		------------------------------------2 - 2번 시작 ------------------------------

		
		
//		(+)public
//		같은 패키지, 다른 패키지 어디서든
//		
//		(#)protect
//		같은 패키지 내 무조건 접근 가능
//		다른 패키지일 경우 상속구조인 클래스에서만 접근 가능
//		
//		(~)default
//		오로지 같은 패키지 내에서만 접근 가능
//		생략할 수 있다
//		
//		(-)private
//		오직 해당 클래스 안에서만 접근 가능
//		
//		=>위에서 아래로 갈 수록 접근 범위가 좁아진다
//		=> 클래스 다이어그램에서 +, #, ~, -로 표기
		
		
//		------------------------------------2 - 2번 끝 ------------------------------

//		------------------------------------2 - 3번 시작 ------------------------------

		
		
		
		//클래스변수(static)변수와 상수필드(static final)
		
		//필드
//		접근제한자 예약어(생략가능) 자료형 필드이름;
		
		public static String staticcc = "static 변수";
		
		
		
//		상수필드
//		public static final 자료형 상수필드 이름 = 값;
//		한 번 지정된 값을 고정해서 사용
//		so, 무조건 초기화 필요
//		예약어 순서는 상관 없다 public final static도 가능
		
//		static : 공유의 개념(재사용성)
//		final : 한번 지정해놓고 변경X(상수선언)
//		
//		값이 변경되어서는 안되는 고정적인 값을 static영역에 올려놓고 공유할 목적
//		
//		상수와 같이 상수필드 이름도 항상 대문자여야한다
		
		
		
//		------------------------------------2 - 3번 끝!!! ------------------------------

		
		
		
//		------------------------------------3번 시작!!! ------------------------------
		Study sy = new Study();
//						생성자
//		생성자 
//		메소드 이름이 클래스 이름과 동일하고 반환형이 없는 메소드
//		new 키워드 이용, 객체가 생성될 때 호출되는 메소드
//		
//		public 클래스이름(매개변수) {
//			해당 생성자를 통해 객체 생성 시 실행하고자 하는 코드
//		}
//		
//		생성자 작성 목적
//		1. 객체 생성
//		2. 매개변수로 전달된 값들을 바로 필드에 초기화 
//		
//		생성자 종류
//		1. 기본생성자(매개변수X)
//		2. 매개변수가 있는 생성자
//		=> 필드에 값을 초기화 할 수 있는지, 없는지 차이!
//		
//		
//		생성자 주의사항
//		1. 반드시 클래스 이름과 동일해야한다
//		2. 반환형이 존재하지 않는다
//			=>메소드와 유사하게 생겨서 혼동 가능함 -> 방지
//		3. 생성자 여러개 생성 가능하지만, 매개변수 중복X 
//			=>오버로딩
//		4. 생성자를 하나도 만들지 않으면 JVM에서 기본 생성자 만들어줌
//			(but 하나라도 만들면 만들어주지 않으므로 만드는 습관 들이기)	
//		
		
		
		
		
		
		
		
//		------------------------------------3번 끝!!! ------------------------------

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
//		------------------------------------3번 끝!!! ------------------------------

		
		
		
		
		
		
}
